## Volatile关键字的原理


#### 1. 前言

> 我们知道volatile关键字的作用是保证变量在多线程之间的可见性，它是java.util.concurrent包的核心，没有volatile就没有这么多的并发类给我们使用。
>
>本文详细解读一下volatile关键字如何保证变量在多线程之间的可见性，在此之前，有必要讲解一下CPU缓存的相关知识，掌握这部分知识一定会让我们更好地理解volatile的原理，从而更好、更正确地地使用volatile关键字。

#### 2. CPU缓存

**CPU缓存的出现主要是为了解决CPU运算速度与内存读写速度不匹配的矛盾，因为CPU运算速度要比内存读写速度快得多**; 这种访问速度的显著差异，导致CPU可能会花费很长时间等待数据到来或把数据写入内存。

基于此，现在CPU大多数情况下读写都不会直接访问内存（CPU都没有连接到内存的管脚），取而代之的是CPU缓存，CPU缓存是位于CPU与内存之间的临时存储器，它的容量比内存小得多但是交换速度却比内存快得多。而缓存中的数据是内存中的一小部分数据，但这一小部分是短时间内CPU即将访问的，当CPU调用大量数据时，就可先从缓存中读取，从而加快读取速度。

#### 使用CPU缓存带来的问题

![缓存模型](/resources/cpu缓存模型.png)

当系统运行时，CPU执行计算的过程如下：

1. 程序以及数据被加载到主内存
2. 指令和数据被加载到CPU缓存
3. CPU执行指令，把结果写到高速缓存
4. 高速缓存中的数据写回主内存

![多核CPU缓存](/resources/多核CPU缓存.png)

试想下面一种情况：

1. 核0读取了一个字节，根据局部性原理，它相邻的字节同样被被读入核0的缓存
2. 核3做了上面同样的工作，这样核0与核3的缓存拥有同样的数据
3. 核0修改了那个字节，被修改后，那个字节被写回核0的缓存，但是该信息并没有写回主存
4. 核3访问该字节，由于核0并未将数据写回主存，数据不同步

**为了解决这个问题，CPU制造商制定了一个规则：`当一个CPU修改缓存中的字节时，服务器中其他CPU会被通知，它们的缓存将视为无效`。于是，在上面的情况下，核3发现自己的缓存中数据已无效，核0将立即把自己的数据写回主存，然后核3重新读取该数据**

#### 3. MESI缓存一致性协议

MESI解决的问题：多线程中使用LOCK#锁总线来解决数据同步问题但实际过程中锁总线的效率太低了,所以**使用多组缓存，但是CPU域内存交互过程中它们的行为看起来只有一组缓存那样**,实现锁总线的功能。**归纳起来说:MESI缓存一致性协议的目的就是要使多组缓存的内容保持一致，来达到CPU与内存交互过程中数据同步的问题**

MESI协议是当前最主流的缓存一致性协议，在MESI协议中，每个缓存行有4个状态，可用2个bit表示，它们分别是：

![缓存一致性](/resources/缓存一致性原理.png)

这里的I、S和M状态已经有了对应的概念：失效/未载入、干净以及脏的缓存段。所以这里新的知识点只有E状态，代表独占式访问，这个状态解决了"在我们开始修改某块内存之前，我们需要告诉其它处理器"这一问题。**只有当缓存行处于E或者M状态时，处理器才能去写它，也就是说只有在这两种状态下，处理器是独占这个缓存行的。当处理器想写某个缓存行时，如果它没有独占权，它必须先发送一条"我要独占权"的请求给总线，这会通知其它处理器把它们拥有的同一缓存段的拷贝失效（如果有）。只有在获得独占权后，处理器才能开始修改数据----并且此时这个处理器知道，这个缓存行只有一份拷贝，在我自己的缓存里，所以不会有任何冲突**。

**反之，如果有其它处理器想读取这个缓存行（马上能知道，因为一直在嗅探总线），独占或已修改的缓存行必须先回到"共享"状态。如果是已修改的缓存行，那么还要先把内容回写到内存中**。

#### 由lock指令回看volatile变量读写

相信有了上面对于lock的解释，volatile关键字的实现原理应该是一目了然了。首先看一张图：

![线程内存模型](/resources/线程内存模型.png)

**工作内存Work Memory其实就是对CPU寄存器和高速缓存的抽象，或者说每个线程的工作内存也可以简单理解为CPU寄存器和高速缓存。**

那么当写两条线程Thread-A与Threab-B同时操作主存中的一个volatile变量i时，Thread-A写了变量i，那么：

* Thread-A发出LOCK#指令
* 发出的LOCK#指令锁总线（或锁缓存行），同时让Thread-B高速缓存*中的缓存行内容失效
* Thread-A向主存回写最新修改的i
*Thread-B读取变量i，那么：
* Thread-B发现对应地址的缓存行被锁了，等待锁的释放，缓存一致性协议会保证它读取到最新的值

**由此可以看出，volatile关键字的读和普通变量的读取相比基本没差别，差别主要还是在变量的写操作上。**

## 总结
读了这篇博客以后，解决了以前一直困惑的问题：线程交互过程中,CPU和内存之间关系。

















#### 参考文献
[https://www.cnblogs.com/xrq730/p/7048693.html](https://www.cnblogs.com/xrq730/p/7048693.html)

[仓颉](http://www.cnblogs.com/xrq730/)
